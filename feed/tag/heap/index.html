<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:wfw="http://wellformedweb.org/CommentAPI/">
<channel>
<title>某储备粮的“学习笔记” - heap</title>
<link>http://blog.gregwym.info/tag/heap/</link>
<atom:link href="http://blog.gregwym.info/feed/tag/heap/" rel="self" type="application/rss+xml" />
<language>zh-CN</language>
<description></description>
<lastBuildDate>Wed, 06 Apr 2011 04:57:39 +0800</lastBuildDate>
<pubDate>Wed, 06 Apr 2011 04:57:39 +0800</pubDate>
<item>
<title>CS 240复习总结之二: Priority Queues </title>
<link>http://blog.gregwym.info/cs-240-fu-xi-zong-jie-zhi-er--priority-queues.html</link>
<guid>http://blog.gregwym.info/cs-240-fu-xi-zong-jie-zhi-er--priority-queues.html</guid>
<pubDate>Wed, 06 Apr 2011 04:57:39 +0800</pubDate>
<dc:creator>咳嗽di小鱼</dc:creator>
<description><![CDATA[Priority Queue 的基础操作:insert: 在Queue中加入一个带有对应优先级的itemdeleteMax: 移除优先级最高的item (此操作仅适用于maximum-oriented...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>Priority Queue 的基础操作:</p><ul>
<li>insert: 在Queue中加入一个带有对应优先级的item</li>
<li>deleteMax: 移除优先级最高的item (此操作仅适用于maximum-oriented priority queue)</li>
<li>deleteMin: 移除优先级最低的item (此操作仅适用于minimum-oriented priority queue)</li>
</ul><p>三种Implementation:</p><ol>
<li>无序array (selection sort) <br />
<br />
<ul>
<li>insert: O(1)</li>
<li>delete: O(n)</li>
</ul></li>
<li>有序array (insertion sort) <br />
<br />
<ul>
<li>insert: O(n)</li>
<li>delete: O(1)</li>
</ul></li>
<li>Heap (一种BST) <br />
<br />
<ul>
<li>insert: O(log n)</li>
<li>delete: O(log n)</li>
</ul></li>
</ol><p>Heap的性质:</p><ol>
<li>从上到下, 从左到右, 必须在一层(level)填满以后再使用下一层</li>
<li>parent的优先级必须大于等于(小于等于 for min-heap)其children的优先级</li>
<li>Heap的高度是Θ(log n)</li>
</ol><p>Heap Insertion:</p><ul>
<li>将新item放入第一个空闲的位置 (参考heap的第一条性质)</li>
<li><p>对其执行bubble-up, 直到符合所有heap性质<br />
 #bubble-up:</p><br />
<br />
<pre><code>while [parent(v) exists and key(parent(v)) &lt; key(v)] do 
    swap v and parent(v) v &lt;- parent(v)
</code></pre></li>
</ul><p>Heap deleteMax/Min:</p><ul>
<li>用heap中的最后一个item取代root</li>
<li><p>对其执行bubble-down, 直到符合所有heap性质</p><br />
<br />
<h1>bubble-down</h1><br />
<br />
<pre><code>while [v is not a leaf] do 
    u &lt;- child of v with largest key 
    if key(u) &gt; key(v) then 
        swap v and u v &lt;- u 
    else 
        break
</code></pre></li>
</ul><p>Heap array的特点 (当前item的位置为i):</p><ul>
<li>Left child位于2i+1</li>
<li>Right child位于2i+2</li>
<li>Parent位于floor[(i-1)/2]</li>
</ul><p>建立heap的两种方法:</p><ul>
<li>以空heap为起始, 逐个item执行insert</li>
<li>以含有n个item的array为起始, 从index为floor[(n-1)/2]的item开始, 逐个执行bubble-down, 直到index 0</li>
</ul><p>注: 使用第二种方法建立heap, 然后执行k次deleteMax/Min, 可快速查找array中第k大的iterm. 运行时间为Θ(n + k log n)</p><p>其他方法请参考: <a href="http://blog.gregwym.info/zhao-shu-zu-vector-nei-di-k-da-de-shu.html">找数组/VECTOR内第K大的数</a></p><p>更多CS 240总结请看: <a href="http://blog.gregwym.info/tag/cs240/">http://blog.gregwym.info/tag/cs240/</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>http://blog.gregwym.info/cs-240-fu-xi-zong-jie-zhi-er--priority-queues.html#comments</comments>
<wfw:commentRss>http://blog.gregwym.info/feed/cs-240-fu-xi-zong-jie-zhi-er--priority-queues.html</wfw:commentRss>
</item>
</channel>
</rss>