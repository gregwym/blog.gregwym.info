<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"
xml:lang="zh-CN"
xml:base="http://blog.gregwym.info/tag/heap/"
>
<title type="text">某储备粮的“学习笔记” - heap</title>
<subtitle type="text"></subtitle>
<updated>2011-04-06T04:57:39+08:00</updated>
<generator uri="http://typecho.org/" version="0.9/13.12.12">Typecho</generator>
<link rel="alternate" type="text/html" href="http://blog.gregwym.info/tag/heap/" />
<id>http://blog.gregwym.info/feed/atom/tag/heap/</id>
<link rel="self" type="application/atom+xml" href="http://blog.gregwym.info/feed/atom/tag/heap/" />
<entry>
<title type="html"><![CDATA[CS 240复习总结之二: Priority Queues ]]></title>
<link rel="alternate" type="text/html" href="http://blog.gregwym.info/cs-240-fu-xi-zong-jie-zhi-er--priority-queues.html" />
<id>http://blog.gregwym.info/cs-240-fu-xi-zong-jie-zhi-er--priority-queues.html</id>
<updated>2011-04-06T04:57:39+08:00</updated>
<published>2011-04-06T04:57:39+08:00</published>
<author>
    <name>咳嗽di小鱼</name>
    <uri>http://blog.gregwym.info</uri>
</author>
<summary type="html"><![CDATA[Priority Queue 的基础操作:insert: 在Queue中加入一个带有对应优先级的itemdeleteMax: 移除优先级最高的item (此操作仅适用于maximum-oriented...]]></summary>
<content type="html" xml:base="http://blog.gregwym.info/cs-240-fu-xi-zong-jie-zhi-er--priority-queues.html" xml:lang="zh-CN"><![CDATA[
<p>Priority Queue 的基础操作:</p><ul>
<li>insert: 在Queue中加入一个带有对应优先级的item</li>
<li>deleteMax: 移除优先级最高的item (此操作仅适用于maximum-oriented priority queue)</li>
<li>deleteMin: 移除优先级最低的item (此操作仅适用于minimum-oriented priority queue)</li>
</ul><p>三种Implementation:</p><ol>
<li>无序array (selection sort) <br />
<br />
<ul>
<li>insert: O(1)</li>
<li>delete: O(n)</li>
</ul></li>
<li>有序array (insertion sort) <br />
<br />
<ul>
<li>insert: O(n)</li>
<li>delete: O(1)</li>
</ul></li>
<li>Heap (一种BST) <br />
<br />
<ul>
<li>insert: O(log n)</li>
<li>delete: O(log n)</li>
</ul></li>
</ol><p>Heap的性质:</p><ol>
<li>从上到下, 从左到右, 必须在一层(level)填满以后再使用下一层</li>
<li>parent的优先级必须大于等于(小于等于 for min-heap)其children的优先级</li>
<li>Heap的高度是Θ(log n)</li>
</ol><p>Heap Insertion:</p><ul>
<li>将新item放入第一个空闲的位置 (参考heap的第一条性质)</li>
<li><p>对其执行bubble-up, 直到符合所有heap性质<br />
 #bubble-up:</p><br />
<br />
<pre><code>while [parent(v) exists and key(parent(v)) &lt; key(v)] do 
    swap v and parent(v) v &lt;- parent(v)
</code></pre></li>
</ul><p>Heap deleteMax/Min:</p><ul>
<li>用heap中的最后一个item取代root</li>
<li><p>对其执行bubble-down, 直到符合所有heap性质</p><br />
<br />
<h1>bubble-down</h1><br />
<br />
<pre><code>while [v is not a leaf] do 
    u &lt;- child of v with largest key 
    if key(u) &gt; key(v) then 
        swap v and u v &lt;- u 
    else 
        break
</code></pre></li>
</ul><p>Heap array的特点 (当前item的位置为i):</p><ul>
<li>Left child位于2i+1</li>
<li>Right child位于2i+2</li>
<li>Parent位于floor[(i-1)/2]</li>
</ul><p>建立heap的两种方法:</p><ul>
<li>以空heap为起始, 逐个item执行insert</li>
<li>以含有n个item的array为起始, 从index为floor[(n-1)/2]的item开始, 逐个执行bubble-down, 直到index 0</li>
</ul><p>注: 使用第二种方法建立heap, 然后执行k次deleteMax/Min, 可快速查找array中第k大的iterm. 运行时间为Θ(n + k log n)</p><p>其他方法请参考: <a href="http://blog.gregwym.info/zhao-shu-zu-vector-nei-di-k-da-de-shu.html">找数组/VECTOR内第K大的数</a></p><p>更多CS 240总结请看: <a href="http://blog.gregwym.info/tag/cs240/">http://blog.gregwym.info/tag/cs240/</a></p>
]]></content>
<link rel="replies" type="text/html" href="http://blog.gregwym.info/cs-240-fu-xi-zong-jie-zhi-er--priority-queues.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="http://blog.gregwym.info/feed/atom/cs-240-fu-xi-zong-jie-zhi-er--priority-queues.html" thr:count="0"/>
</entry>
</feed>